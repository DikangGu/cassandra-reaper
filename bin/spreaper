#!/usr/bin/env python
# Copyright (c) 2014 Spotify AB
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
#
import getpass
import json
import logging
import requests
import sys
import urlparse

from spotify.util import cmdline

USER = getpass.getuser()
DEFAULT_CAUSE = "manual spreaper run"

log_level = logging.WARN
if "-v" in sys.argv or "--verbose" in sys.argv:
    log_level = logging.DEBUG
logging.basicConfig(level=log_level, format='%(asctime)s %(name)s %(levelname)s - %(message)s')

log = logging.getLogger("spreaper")
log.debug("logging initialized, the user running this: {0}".format(USER))


# === Class dealing with interfacing with the reaper ==================================


class ReaperCaller(object):
    """Implements the functionality for calling the Reaper service.
    Keep the CLI specific stuff in ReaperCLI."""
    def __init__(self, host_name, host_port, use_ssl):
        self.base_url = "{0}://{1}:{2}".format(use_ssl and 'https' or 'http',
                                               str(host_name), int(host_port))

    def _http_req(self, http_method, the_url, params=None):
        http_method = http_method.upper()
        if params is None:
            params = {}
        log.info("making HTTP %s to %s", http_method, the_url)
        if http_method == 'GET':
            r = requests.get(the_url, params=params)
        elif http_method == 'POST':
            r = requests.post(the_url, params=params)
        else:
            assert False, "invalid HTTP method: {0}".format(http_method)
        log.info("HTTP %s return code %s with content of length %s",
                 http_method, r.status_code, len(str(r.text)))
        r.raise_for_status()
        return r.text

    def call_list_clusters(self):
        the_url = urlparse.urljoin(self.base_url, "cluster")
        reply = self._http_req("GET", the_url)
        return json.loads(reply)

    def call_register(self, owner, seed_host=None, cluster_name=None, keyspace=None, table=None,
                      cause=None, repair_immediately=False):
        if not seed_host and not cluster_name:
            print "either seed-host or cluster-name required for registering cluster"
            exit(1)
        if cluster_name:
            params = {"clusterName": cluster_name}
        else:
            params = {"seedHost": seed_host}

        if not keyspace and not table:
            if repair_immediately:
                print "you cannot repair whole cluster, but must define table and keyspace name"
                exit(1)
            the_url = urlparse.urljoin(self.base_url, "cluster")
        elif not keyspace or not table:
            print "both 'keyspace' and 'table' (or neither) required for registering"
            exit(1)
        else:
            the_url = urlparse.urljoin(self.base_url, "table")
            params['keyspace'] = keyspace
            params['table'] = table
            params['owner'] = owner
            params['cause'] = cause and cause or DEFAULT_CAUSE
            if repair_immediately:
                params['startRepair'] = 'true'

        reply = self._http_req("POST", the_url, params=params)
        return json.loads(reply)

    def call_status_cluster(self, cluster_name):
        the_url = urlparse.urljoin(self.base_url, "cluster/{0}".format(cluster_name))
        reply = self._http_req("GET", the_url)
        return json.loads(reply)

    def call_status_repair(self, repair_run_id):
        the_url = urlparse.urljoin(self.base_url, "repair_run/{0}".format(repair_run_id))
        reply = self._http_req("GET", the_url)
        return json.loads(reply)

    def call_ping(self):
        the_url = urlparse.urljoin(self.base_url, "ping")
        return self._http_req("GET", the_url)

# === actual CLI commands ===========================================================


def init_reaper(opts, args):
    return ReaperCaller(opts.reaper_host, opts.reaper_port, opts.use_ssl)


@cmdline.command(usage='status-cluster cluster_name')
def cmd_status_cluster(opts, args):
    """Show status of a cluster, including the repairs for the cluster
    """
    if len(args) == 0 or args[0] is None:
        print "Please specify a cluster name"
    else:
        reaper = init_reaper(opts, args)
        print "# cluster '{0}':".format(args[0])
        cluster_data = reaper.call_status_cluster(args[0])
        print json.dumps(cluster_data, indent=2)


@cmdline.command(usage='status-repair repair_run_id')
def cmd_status_repair(opts, args):
    """Show status of a repair run
    """
    if len(args) == 0 or args[0] is None:
        print "Please specify a repair run ID"
    else:
        reaper = init_reaper(opts, args)
        print "# repair run with id {0}".format(args[0])
        repair_run = reaper.call_status_repair(args[0])
        print json.dumps(repair_run, indent=2)


def opts_trigger(group):
    group.add_option('--seed-host', dest='seed_host', default=None, type='string',
                     help="the seed host of the target Cassandra cluster")
    group.add_option('--cluster-name', dest='cluster_name', default=None, type='string',
                     help="the name of the target Cassandra cluster")
    group.add_option('--owner', dest='owner', default=USER, type='string',
                     help="name of local user calling the Reaper [{0}]".format(USER))
    group.add_option('--cause', dest='cause', default=DEFAULT_CAUSE, type='string',
                     help='cause string used for logging and auditing purposes [\"{0}\"]'
                     .format(DEFAULT_CAUSE))
    group.add_option('--keyspace', dest='keyspace', default=None, type='string',
                     help="the keyspace in the Cassandra cluster")
    group.add_option('--table', dest='table', default=None, type='string',
                     help="the table within a keyspace in the Cassandra cluster")


@cmdline.command(usage='repair <cluster_name>', add_options=opts_trigger)
def cmd_repair(opts, args):
    """Trigger a repair on a Cassandra cluster
    """
    reaper = init_reaper(opts, args)
    if opts.cluster_name:
        print "# triggering a repair on Cassandra cluster " \
              "with name: {0}".format(opts.cluster_name)
        reply = reaper.call_register(opts.owner, cluster_name=opts.cluster_name,
                                     keyspace=opts.keyspace, table=opts.table,
                                     cause=opts.cause, repair_immediately=True)
    else:
        print "# triggering a repair on Cassandra cluster " \
              "with seed host: {0}".format(opts.seed_host)
        reply = reaper.call_register(opts.owner, seed_host=opts.seed_host,
                                     keyspace=opts.keyspace, table=opts.table,
                                     cause=opts.cause, repair_immediately=True)
    print "# repair triggering succeeded. reply:"
    print reply


def opts_register(group):
    group.add_option("--trigger-repair", default=False, action='store_true',
                     help="trigger repair immediately upon successful register [False]")
    opts_trigger(group)


@cmdline.command(usage='register', add_options=opts_register)
def cmd_register(opts, args):
    """Register a Cassandra cluster for repairs
    """
    reaper = init_reaper(opts, args)
    print "# registering Cassandra cluster with seed host: {0}".format(opts.seed_host)
    reaper.call_register(opts.owner, opts.seed_host)
    print "# registration succeeded"


@cmdline.command(usage='list-clusters')
def cmd_list_clusters(opts, args):
    """List all registered Cassandra clusters
    """
    reaper = init_reaper(opts, args)
    print "# listing all available clusters in the Reaper"
    cluster_names = reaper.call_list_clusters()
    if cluster_names:
        print "# found {0} clusters:".format(len(cluster_names))
        for cluster_name in cluster_names:
            print cluster_name
    else:
        print "no clusters found"


def add_global_options(group):
    group.add_option("--reaper-host", dest='reaper_host', default="localhost", type='string',
                     help="hostname of the Reaper service [localhost]")
    group.add_option("--reaper-port", dest='reaper_port', default="8080", type='string',
                     help="port of the Reaper service [8080]")
    group.add_option("--reaper-use-ssl", dest='use_ssl', default=False, action='store_true',
                     help="use https to call Reaper [False]")


if __name__ == '__main__':
    cmdline.main("reaper: Repair Cassandra clusters.",
                 add_global_optgroup=add_global_options)

